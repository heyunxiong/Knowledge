# 【读】Java8 实战 - 第二版

# 1.1 为什么还要关心Java的变化

Java8提供了一个新的API（称为“流”，Stream），它支持读后个数据处理的并行操作，其思路和数据库查询语句类似，从高层的角度描述需求，而由“实现”（这里是Stream）来选择底层最佳执行时机。

在java8中加入Stream可以视为添加另外两项的直接原因：向方法传递代码的简洁技巧（方法引用、Lambda） 和接口中的默认方法。能简洁的表达行为参数化。

java8里将代码传递给方法的功能，成为**函数式编程**。

## 1.2 java怎么还在变

## 1.2.2 流处理

流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流

 **Stream<T> 就是一系列 T 类型的项目**

Java 8增加了把方法（你的代码）作为参数传递给另一个方法的能力。我们把这一概念称为行为参数化

Stream API就是构建在通过传递代码使操作行为实现参数化的思想上的，当把compareUsingCustomerId 传进去，你就把sort 的行为参数化了



## 1.2.4 并行与共享的可变数据

你提供的行为必须能够同时在不同的输入上安全地执行。一般情况下这就意味着，所写的代码不能访问共享的可变数据来完成它的工作

Java 8的流实现并行比 Java现有的 Thread API更容易，因此，尽管可以使用 synchronized
来打破“不能有共享的可变数据”这一规则，但这相当于是在和整个体系作对，因为它使所有围
绕这一规则做出的优化都失去意义了

没有共享的可变数据，以及将方法和函数（即代码）传递给其他方法的能力，这两个要点是
函数式编程范式的基石



在命令式编程范式中，你写的程序则是一系列改变状态的指令。“不能有共享的可变数据”意味着，一个方法可以通过它将参数值转换为结果的方式来完整描述，换句话说，它的行为就像一个数学函数，没有可见的副作用

## 1.3 Java中的函数

编程语言的整个目的就在于操作值，按照历史上编程语言的传统，这些值应被称为一等值（或一等公民）。编程语言中的其他结构也许有助于表示值的结构，但在程序执行期间不能传递，因而是二等值。前面所说的值是 Java 中的一等值，但其他很多 Java 概念（比如方法和类等）则是二等值。（@me：所以现在就开始想着把方法提升地位到一等公民。而且好处很多）

### 1.3.1 方法和Lambda作为一等值

 Java 8的方法引用 :: 语法（即“把这个方法作为值”）将其传给 listFiles 方法

``` File[] hiddenFiles = new File(".").listFiles(File::isHidden);```

Lambda——匿名函数

Java8 还体现了将函数作为值的思想，Lambda表达式（或匿名函数）

(int x) -> x + 1 ，表示“调用时给定参数 x，就返回 x + 1值的函数”。

### 1.3.2 一个例子

> 什么是谓词？
> 前面的代码传递了方法 Apple::isGreenApple （它接受参数 Apple 并返回一个
> boolean ）给 filterApples ，后者则希望接受一个 Predicate<Apple> 参数。谓词（predicate）在数学上常常用来代表类似于函数的东西，它接受一个参数值，并返回 true 或 false 。后面你会看到，Java 8 也允许你写 Function<Apple,Boolean> ——在学校学过函数却没学过谓词的读者对此可能更熟悉，但用 Predicate<Apple> 是更标准的方式，效率也会更高一点儿，这避免了把 boolean 封装在 Boolean 里面。

## 1.4 流

现在值得注意的是，Stream API处理数据的方式与 Collection API不同。用集合的话，你得自己管理迭代过程。你得用 for-each 循环一个个地迭代元素，然后再处理元素。我们把这种数据迭代方法称为外部迭代。相反，有了 Stream API，你根本用不着操心循环的事情。数据处理完全是在库内部进行的。我们把这种思想叫作内部迭代。

- 多线程并非易事
	- Java 8也用 Stream API（ java.util.stream ）解决了这两个问题：集合处理时的模板化和晦涩，以及难以利用多核

Collection 主要是为了存储和访问数据，Stream则主要用于描述对数据的计算

## 1.5 默认方法及java模块

Java 8的解决方法就是打破最后一环——接口如今可以包含实现类没有提供实现的方法签名
了！那谁来实现它呢？缺失的方法主体随接口提供了（因此就有了默认实现），而不是由实现类提供。

一个类可以实现多个接口，不是吗？那么，如果在好几个接口里有多个默认实现，是否意味着 Java中有了某种形式的多重继承？是的，在某种程度上是这样。第 13章中会谈到，Java 8用一些限制来避免出现类似于 C++中臭名昭著的菱形继承问题。

## 1.6 来自函数编程的其他好思想

 Java从函数式编程引入的两个核心思想：将方法和 Lambda作为一等值，以及
在没有可变共享状态时，函数或方法可以有效、安全地并行执行。这两种思想新的 Stream API都用到了