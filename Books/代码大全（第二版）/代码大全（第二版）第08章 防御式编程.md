## 第8章 防御式编程

## 8.1 保护程序免遭非法输入数据的破坏
检查所有来源于外部的数据的值 （文件，	用户，	网络）
检查子程序所有输入参数的值
决定如何处理错误的输入数据

## 8.2 断言
断言，开发期间使用的，让程序在运行时进行自检的代码。 断言为真，测试通过，断言为假，代码中有意料之外的错误

使用断言情形
- 输入输出参数的取值处于预期范围内
- 文件或流已用只读，只写或可读可写方式打开
- 指针非空
- 容器空或者满
。。。

断言主要适用于开发和维护阶段，生产环境并不会编译进去

建立自己的断言机制

使用断言建议
- 用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况
- 避免把需要执行的代码放在断言中   不然自己的代码到了生产环境就没有了
- 用断言来注解并验证前条件和后条件  断言执行前和执行后
- 对于高健壮性的代码，应该先使用断言再处理错误  可能出错的条件，要么使用断言，要么使用错误处理代码来进行处理，但是不会同时使用


## 8.3 错误处理技术
断言可以用于处理代码中不应该发生的错误，该如何处理预料中的错误呢？
- 返回中立值    
- 换用下一个正确的数据
- 返回与前次相同的数据
- 把警告信息记录到日志文件中
- 返回一个错误码
- 调用错误处理子程序或对象（即返回错误对象）
- 显示错误的信息
- 用对稳妥的方式处理局部错误
- 关闭程序   出现错误就关闭程序，这种做法很危险。除非是信息安全攸关的系统

健壮性与正确性
正确性意味着永远不返回不准确的结果，健壮性则意味着要不断尝试采取某些措施，以保证软件可以持续地运转下去，哪怕有时候会出现不够准确地结果

## 8.4 异常
异常时把代码中地错误或异常事件传递给调用方代码的一种特殊手段。
一些建议
- 用异常通知程序的其他部分，发生了不可忽略的错误
- 只在真正例外的情况下才抛出异常
- 不能用异常来推卸责任
- 避免在构造函数和析构函数中抛出异常，除非在同一个地方捕获
- 在恰当的抽象层次抛出异常
- 在异常消息中加入关于导致异常发生的全部信息
- 避免使用空的catch语句
- 了解所用函数库可能抛出的异常
- 考虑建立一个集中的异常报告机制
- 对异常的使用进行标准化处理

## 8.5 隔离程序
隔栏是一种容损策略，即容灾性
即对安全区域的边界进行数据的合法性校验等。
![](_assets/_file_代码大全（第二版）第08章%20防御式编程/img-代码大全（第二版）第08章%20防御式编程-20220729_171921686.png)

隔离和断言的关系
隔离的使用使断言和错误处理有了清晰的区分，隔栏外部的程序应使用错误处理技术，对数据进行假定的校验等，隔栏内部的程序应该做断言技术，因为传进来的数据已经处理过了。

## 8.6 辅助调试的代码
不要把生产环境上的限制强加于开发环境中  即生产环境的严格资源限制等在开发中可以先去掉

尽早引入辅助调试的代码

采用进攻式编程   即在开发阶段让异常显现出来，而在生产环境中出现错误的时候，能自动恢复
一些进攻式方法，即能预见到这个处理的时候有什么特别的异常出现
- 确保断言的处理
- case语句的处理
- 文件读取的判断
- ....

计划移除调试辅助的代码
对于商用软件，调试代码会使软件的体积变大而且速度慢，应该合理的计划移除调试代码
- 使用版本工具   控制不同版本的程序
- 使用内置的预处理器   使用编译器开关来包含或排除调试用的代码
- 编写自己的预处理器   自行移除调试代码的脚本或者程序
- 使用调试存根 

## 8.7 保留防御式代码
保留检查重要错误的代码
去掉检查细微错误的代码
去掉让程序直接崩溃的代码
保留可以让程序稳妥地奔溃地代码，即能保证数据方面不会丢失之类地
记录错误信息
确认保留地错误信息式友好的，检查起来快速的。

## 8.8 采取防御的姿态
要考虑好什么地方需要进行防御，然后因地制宜地调整进行防御式编程的优先级

2022年7月29日
Yunxiong
