# 第24章 重构（refactoring）
神话级别的开发过程，完善的需求文档，程序员线性开发即刻，测试通过后交付，唯一的修改就是维护
现实：需求的不断变更，测试覆盖率没达标，代码需要改变
另一个事实：现在开发已经放弃了代码的前瞻性，以代码为中心，在项目的生命周期中不断地演化或优化
## 24.1 软件演化的类型
软件演化如同生物进化，有好有坏，好的演化即程序质量提高了。
演化的在构建过程中修改还是在软件维护时修改，构建中的由开发人员修改比较容易，受影响小。维护的话就是线上问题了，处理起来比较麻烦
在开始编写程序时，你绝对不会对程序有深入的理解，一旦有机会重新审视你的程序，就要用自己的全部所学去改进它，思考原来的代码和现在的改变在将来可能如何变化，这一过程非常有益。

## 24.2 重构简介
重构的定义
Martin Fowler：在不改变软件外部行为的前提下，对其内部结构进行改变，使之更容易理解并便于修改。

重构的理由
- 代码重复
- 冗长的子程序（方法）
- 循环过长或嵌套过深
- 内聚性太差的类   即某个类大包大揽了需要彼此无关的任务，考虑拆分成多个类，即单一职责
- 类的接口未能提供层次一致的抽象
- 拥有太多参数的参数列表
- 类的内部修改往往被局限于某个部分  即修改的部分，不影响别的部分，说明是独立的，考虑拆分多个类
- 变化导致对多个类的相同修改
- 对继承的同样修改  即添加子类时，对别的子类需要做同样的操作
- 常常对同样一组数据进行操作 考虑封装成一个类
- 成员函数使用其他类的特征比使用自身类的特征还要多   考虑拆到另一个类中
- 过多使用基本数据类型  如果用于表示现实中实体事务，考虑用类封装
- 某个类无所事事  删掉
- 传递流量数据的方法，把数据传递给某个子程序，仅仅为了让改子程序把数据传给另一个子程序
- 子程序命名不恰当
- 数据成员被设置成公用
- 某个子类仅使用了基类的很少一部分成员函数  
- 注释被用于解释难懂的代码
- 使用了全局变量
- 未来能够使用的代码

## 24.3 特定的重构

数据级的重构
- 用具名常量替代神秘数值
- 变量名清晰明确
- 表达式内联化  中间变量接受复杂的表达式结果
- 用函数替代表达式
- 引入中间变量
- 用多个单一用途的变量替代多个用途的变量。 比如循环里面 i、j、k； temp等。
- 在局部用途中使用局部变量而不是参数。 即在方法内部声明变量接受参数，而不是直接使用入参
- 将基础数据类型转化为类  枚举类Color、Shape、Country这种

语句级的重构
改善单个语句的是使用
- 分解布尔表达式   中间变量接受判断过程，简化判断的处理
- 复杂的布尔表达式转换成布尔函数
- 合并条件语句不同部分中的重复代码片段
- 使用break和return控制循环
- 在嵌套的if-then-else 语句中一旦知道答案就立即返回，而不是去赋一个返回值 
- 创建和使用null对象而不是去检测空值

子程序级的重构
- 提取子程序或方法
- 将子程序的代码内联化  简单的代码可直接使用
- 将冗长的子程序转换为类
- 用简单算法替代复杂算法
- 增加参数
- 删除参数
- 将查询操作从修改操作中独立出来
- 合并相似的子程序，通过参数区分它们的功能
- 将行为取决于参数的子程序拆分开来
- 传递整个对象而非特定成员
- 传递特定成员而非整个对象
- 包装向下转型的操作   即传递父类或接口

类的重构
- 将值对象转化成引用对象   多个大型复杂的对象，用引用方式
- 将引用对象转化成值对象
- 用数据初始化替代虚函数
- 改变成员函数或者成员数据的位置
- 将特殊代码提取为派生类
- 将相似代码提取到基类中

类接口的重构
- 将成员函数放到另一个类中
- 引入外部的成员函数
- 引入扩展类
- 对暴露在外的成员变量进行封装
- 对于不能修改的类成员，删除相关的set函数
- 合并实现相似的基类和派生类

系统的重构
- 为无法控制的数据创建明确的索引源-
- 将单向的类联系改为双向的类联系
- 将双向的类联系改为单向的类联系
- 使用factorymethod创建对象
- 用异常取代错误处理代码


不宜重构的情况
- 不要把重构当作先写后改的代名词
- 避免用重构替代重写


2022年7月22日
Yunxiong
