# 第7章 虚拟机类加载机制

## 概述
Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。

**虚拟机的类加载机制**：java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型的过程
在java中，类型的加载，连接和初始化过程都是在程序运行期间完成的。
	劣势：类加载的性能开销增大
	优势：可动态扩展。java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

## 类加载的时机
类的生命周期：加载loading --> 验证verification --> 准备preparation --> 解析resolution --> 初始化initialization -->使用using -->卸载unload；
验证verification --> 准备preparation --> 解析resolution 这三个阶段称为连接linking；
固定不变的阶段顺序：加载loading --> 验证verification --> 准备preparation --> 初始化initialization  -->卸载unload； 解析阶段在某些情况下可以在初始化后在开始，为了支持java语言的运行时绑定特性。

6中java虚拟机规范规定的**必须立即**进行“类初始化”的情况（称为对一个类型的主动引用， 其他的引用类型的方式称为被动引用）
1. 遇到new，getstatic，putstatic或invokestatic这四条字节码指令时
2. 使用java.lang.reflect包的方法对类型进行反射调用的时候
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
4. 用户需要指定一个要执行的主类（包含main方法的类），虚拟机会先初始化这个主类
5. jdk7新加入的特性，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄
6. jdk8的默认方法（被default关键字修饰的接口方法）如果有这个接口的实现类进行初始化的场景，则该接口需要在实现类之前被初始化

被动引用例子：
- 对于静态字段，只有直接定义这个字段的类才会被初始化，被动引用下，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
- 通过数组定义来引用类，不会触发此类的初始化
- 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

接口的加载和类的加载稍有不同：类在初始化时，需要其父类全部已经初始化，而接口在初始化时，并不要求其父接口全部完成初始化，只有真正使用到其父接口的时候才会初始化。


## 类加载的过程
### 加载
加载是类加载过程中的一个阶段（面试问的是类加载的过程，不是单单指加载阶段）
