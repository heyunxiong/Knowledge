# 第7章 虚拟机类加载机制

## 概述
Class文件中描述的各类信息，最终都需要加载到虚拟机中之后才能被运行和使用。

**虚拟机的类加载机制**：java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型的过程
在java中，类型的加载，连接和初始化过程都是在程序运行期间完成的。
	劣势：类加载的性能开销增大
	优势：可动态扩展。java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

## 类加载的时机
类的生命周期：加载loading --> 验证verification --> 准备preparation --> 解析resolution --> 初始化initialization -->使用using -->卸载unload；
验证verification --> 准备preparation --> 解析resolution 这三个阶段称为连接linking；
固定不变的阶段顺序：加载loading --> 验证verification --> 准备preparation --> 初始化initialization  -->卸载unload； 解析阶段在某些情况下可以在初始化后在开始，为了支持java语言的运行时绑定特性。

6中java虚拟机规范规定的**必须立即**进行“类初始化”的情况（称为对一个类型的主动引用， 其他的引用类型的方式称为被动引用）
1. 遇到new，getstatic，putstatic或invokestatic这四条字节码指令时
2. 使用java.lang.reflect包的方法对类型进行反射调用的时候
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
4. 用户需要指定一个要执行的主类（包含main方法的类），虚拟机会先初始化这个主类
5. jdk7新加入的特性，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄
6. jdk8的默认方法（被default关键字修饰的接口方法）如果有这个接口的实现类进行初始化的场景，则该接口需要在实现类之前被初始化

被动引用例子：
- 对于静态字段，只有直接定义这个字段的类才会被初始化，被动引用下，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
- 通过数组定义来引用类，不会触发此类的初始化
- 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

接口的加载和类的加载稍有不同：类在初始化时，需要其父类全部已经初始化，而接口在初始化时，并不要求其父接口全部完成初始化，只有真正使用到其父接口的时候才会初始化。

## 类加载的过程
### 加载阶段
加载是类加载过程中的一个阶段（面试问的是类加载的过程，不是单单指加载阶段）
在加载阶段，java虚拟机完成的三件事：
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成代表此类的Class对象，作为这个类的各个数据的访问入口

非数组类型的加载阶段是开发人员可控性最强的阶段；既可以使用java虚拟机内置的引导类加载器，也可以使用用户自定义的类加载器去完成

对于数组类而言，本身不通过类加载器创建，由java虚拟机直接在内存中动态构造出来
数组类的创建过程
- 如果数组的组件类型是引用类型（即User[] ），递归采用加载过程去加载这个组件，数组将被标识在加载该组件类型的类加载器的类名称空间上
- 如果组件类型不是引用类型（例如：int[] 的组件类型是int）java虚拟机会把数组标记为与引导类器关联
- 数组类的可访问性与组件类型的可访问性一致。如果不是引用类型，默认public

加载阶段完成后，二进制字节流就按照java虚拟机规定的格式存储在方法区中。

### 验证阶段
验证是连接阶段的第一步，目的是确保Class文件的字节流中包含的信息符合java虚拟机规范的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机的安全（因为Class文件的并不一定是java源码编译的，而且来源广泛）

**1.文件格式验证**
验证字节流是否符合Class文件格式的规范：
- 是否已魔数0xCAFEBABE开头
- 主、次版本号是否在当前虚拟机接受范围内
- 常量池的常量是否有不被支持的常量类型
- ...
一系列检查主要目的是确保输入的字节流能够正确地被解析并存储于方法区之内，通过验证阶段才被允许进入java虚拟机内存的方法区中进行存储。

**2.元数据验证**
对字节码描述的信息进行语义分析，保证其描述的信息符合java虚拟机规范
- 这个类是否有父类
- 这个类的父类是否继承了不允许被继承的类（final）
- 如果这个类不是抽象类，时候实现了父类的所有方法
- ...

**3.字节码验证**
验证过程最复杂的阶段，目的是通过数据流分析何控制流分析，确定程序语义是合法的、符合逻辑的。
> 新增StackMapTable属性 的作用就是为了节省大量的校验时间

**4.符号引用验证**
最后一个验证阶段，发生在虚拟机将符号引用转化为直接引用的时候。
符号引用验证可以看作是对类自身以外的各类信息进行匹配性校验，即看该类是否缺少或被禁止访问它依赖的外部类、方法、字段等
- 符号引用中通过字符串描述的全限定名能否找到对应的类
- 是否存在符合方法的字段描述符及简单名称所描述的方法和字段
- 符号引用中的类、字段、方法的可访问性是否可被当前类访问
- ...

### 准备阶段
正式为类中定义的变量（即static修饰的静态变量）分配内存并设置类变量初始值的阶段（变量的内存逻辑上来说应该是方法区，但是jdk7和jdk8有区别，jdk使用永生代来实现方法区；而jdk8的类变量会和Class对象一起存放在java堆中）

注意：
- 内存分配的变量只是类变量，不包括实例变量；实例变量会和对象一起放在java堆中
- 对于public static int value =123; 变量value在准备阶段过后的初始值是0，而不是123。因为这是尚未开始执行任何java方法，而value的赋值指令putstatic是程序编译后，即赋值的动作要到类的初始化阶段才会被执行；
- 而public static  **final** int value =123，准备阶段后是value就被赋值为123

### 解析阶段
java虚拟机将常量池内的**符号引用**换成为**直接引用**的过程
符号引用
符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。引用的目标并不一定是已加载到虚拟机内存当中的内容

直接引用
直接引用是可以直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄，引用目标必须在java虚拟机内存上

**1.类或者接口的解析**

**2.字段解析**

**3.方法解析**

**4.接口方法解析**

### 初始化阶段

类的初始化时类加载过程的最后一个步骤；前面几个类加载阶段，除了加载阶段是用户可以自定义类加载器的方式外，其他的动作都是由java虚拟机主导控制的。直到初始化阶段，java虚拟机才真正开始执行类中编写的java程序代码，将主导权移交给应用程序
初始化阶段就是执行类构造器<clinit>()方法的过程。
- <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{ }块）中的语句合并产生的；静态语句块中只能访问到定义在静态语句之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问
- <clinit>()方法与类的构造方法（即java虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式调用父类构造方法，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕
- 由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块优先于子类的变量赋值操作
- <clinit>()方法对于类或者接口来说不是必要的，因为有些类没有静态语句块，也就不需要生成<clinit>()方法
- 接口中不能使用静态代码块，但有变量初始化的操作，和类一样会生成<clinit>()方法；但不同的是，接口只有当父接口中定义的变量被使用时，父接口才会被初始化。
- java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，不然会造成多线程同时初始化一个类，造成阻塞。

## 类加载器
有意把类加载阶段中加载过程的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放在java虚拟机外部去实现，让应用程序自己决定从哪里，如何获取所需的类，实现这个功能的代码叫做：类加载器 Class Loader

### 类与类加载器
类加载器只用于实现类加载的加载阶段；
比较两个类是否相等，只有在这两个类都是由同一个类加载器加载的前提下才有意义；否则即使两个类来源同一个Class文件，被同一个java虚拟机加载，只要加载他们的类加载器不同，那这两个类必然不同

### 双亲委派模型
从java虚拟机角度分类：类加载器：
1.启动类加载器：bootstrap classloader 使用c++语言实现，是虚拟机自身一部分（限于hotspot虚拟机）
2.其他类加载器：java语言实现，独立于虚拟机外部，并继承抽象类java.lang.ClassLoader类

从开发者角度分类：类加载
1.启动类加载器
负责加载javaHome下的lib目录下，或者被-Xbootclasspath指定的类

2.扩展类加载器 extension classloader
这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库

3.应用程序加载器 application classloader，默认类加载器
由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，也称“系统类加载器”
负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用该类加载器
如果应用程序中没有自定义过自己的类加载器，一般情况下，就是默认类加载器。

![](_assets/深入理解Java虚拟机%20第7章%20虚拟机类加载机制/image-深入理解Java虚拟机%20第7章%20虚拟机类加载机制-20221024-162116898.png)

各种类加载器之间的层次关系被称为类加载器的”双亲委派模型“，一般不是以继承的关系实现，而是用组合的关系来复用父加载器的代码

** 双亲委派的工作过程：**
双亲委派的工作过程是：如果一个类加载器手到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载

``` java
protected synchronized Class < ? > loadClass(String name, boolean resolve) throws ClassNotFoundException
{

Class c = findLoadedClass(name);
if (c == null) {
try {
if (parent != null) {
c = parent.loadClass(name, false);
} else {
c = findBootstrapClassOrNull(name);
}
} catch (ClassNotFoundException e) {

}
if (c == null) {

c = findClass(name);
}
}
if (resolve) {
resolveClass(c);
}
return c;
}
```

### 破坏双亲委派
// 一段历史故事
......

## Java模块化系统
在jdk9中引入了java模块化系统java platform module system JPMS

### 模块的兼容性
...
### 模块化的类加载器
...
