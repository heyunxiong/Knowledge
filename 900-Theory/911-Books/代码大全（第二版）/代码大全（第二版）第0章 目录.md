封面
书名
版权
前言
目录
正文

==第1部分 基础==
第1 章 欢迎进入软件构建的世界
1 . 1 什么是软件构建
1 . 2 软件构建为何如此重要
1 . 3 如何阅读本书
关键点
第2 章 用隐喻来更充分地理解软件开发
2 . 1 隐喻的重要性
2 . 2 如何使用软件隐喻
2 . 3 常见的软件隐喻
软件中的书法：写作代码
软件的耕作法：培植系统
软件的牡蛎养殖观点：系统生长
软件构建：建造软件
应用软件技术：智慧工具箱
组合各个隐喻
更多资源
关键点
第3 章 三思而后行：前期准备
3 . 1 前期准备的重要性
前期准备适用于现代软件项目吗
准备不周全的诱因
关于开始构建之前要做前期准备的绝对有力且简明的论据
3 . 2 辨明你所从事的软件的类型
迭代开发法对前期准备的影响
在序列式开发法和迭代式开发法之间做出选择
3 . 3 问题定义的先决条件
3 . 4 需求的先决条件
为什么要有正式的需求
稳定需求的神话
在构建期间处理需求变更
3 . 5 架构的先决条件
架构的典型组成部分
3 . 6 花费在前期准备上的时间长度
更多资源
关键点
第4 章 关键的“构建”决策
4 . 1 选择编程语言
语言描述
4 . 2 编程约定
4 . 3 你在技术浪潮中的位置
“深入一种语言去编程”的例子
4 . 4 选择主要的构建实践方法
关键点

==第2部分 创建高质量的代码==
第5 章 软件构建中的设计
5 . 1 设计中的挑战
设计是一个险恶的问题
设计是个了无章法的过程（即使它能得出清爽的成果）
设计就是确定取舍和调整顺序的过程
设计受到诸多限制
设计是不确定的
设计是一个启发式过程
设计是自然而然形成的
5 . 2 关键的设计概念
软件的首要技术任务：管理复杂度
理想的设计特征
设计的层次
5 . 3 设计构造块：启发式方法
寻找现实世界中的对象
形成一致的抽象
封装实现细节
当继承能简化设计时就继承
隐藏秘密（信息隐藏）
找出容易改变的区域
保持松散耦合
查阅常用的设计模式
其他的启发式方法
关于设计启发的总结* * * * *
使用启发式方法的原则
5 . 4 设计实践
迭代
分而治之
自上而下和自下而上的设计方法
建立试验性原型
合作设计
要做多少设计才够？
记录你的设计成果
5 . 5 对流行的设计方法的评论
更多资源
软件设计，一般性问题
软件设计理论
设计模式
广义的设计
标准
关键点
第6 章 可以工作的类
6 . 1 类的基础：抽象数据类型
需要用到A D T 的例子
使用A D T 的益处
更多的A D T 示例
在非面向对象环境中用A D T 处理多份数据实例
A D T 和类
6 . 2 良好的类接口
好的抽象
良好的封装
6 . 3 有关设计和实现的问题
包含（“有一个⋯⋯”的关系）
继承（“是一个⋯⋯”关系）
成员函数和数据成员
构造函数
6 . 4 创建类的原因
应该避免的类
总结：创建类的理由
与具体编程语言相关的问题
6 . 6 超越类：包
更多资源
关键点
第7 章 高质量的子程序
7 . 1 创建子程序的正当理由
似乎过于简单而没必要写成子程序的操作
总结：创建子程序的理由
7 . 2 在子程序层上设计
7 . 3 好的子程序名字
7 . 4 子程序可以写多长
7 . 5 如何使用子程序参数
7 . 6 使用函数时要特别考虑的问题
什么时候使用函数，什么时候使用过程
设置函数的返回值
7 . 7 宏子程序和内联子程序
宏子程序在使用上的限制
内联子程序
关键点
第8 章 防范式编程
8 . 1 保护程序免遭无效输入数据的破坏
8 . 2 断言
建立自己的断言机制
使用断言的指导建议
8 . 3 错误处理技术
健壮性与正确性
高层次设计对错误处理方式的影响
8 . 4 异常
8 . 5 隔离程序以免遭由错误造成的损害
隔离区与断言的关系
8 . 6 辅助调试代码
不要自动地把产品版本的限制强加于开发版本之上
尽早引入辅助调试的手段
采用冒进式编程
计划移除调试辅助代码
8 . 7 确定在产品代码中该保留多少防范式代码
8 . 8 防范式编程时保持防范
其他资源
关键点
第9 章 伪代码编程过程
9 . 1 创建类和子程序的步骤概述
创建一个类的步骤
创建子程序的步骤
9 . 2 伪代码
9 . 3 通过伪代码编程过程创建子程序
设计子程序
编写子程序
检查代码
收尾工作
根据需要重复上述步骤
9 . 4 伪代码编程过程之外的其他方案
关键点

==第3部分 变量==
第1 0 章 使用变量的一般事项
1 0 . 1 数据认知
数据认知测试
有关数据类型的其他资源
1 0 . 2 轻松掌握变量定义
隐式声明
1 0 . 3 变量初始化原则
1 0 . 4 作用域
使变量引用局部化
尽可能缩短变量的“存活”时间
减小作用域的一般原则
有关缩小变量作用域的说明
1 0 . 5 持续性
1 0 . 6 绑定时间
1 0 . 7 数据类型和控制结构之间的关系
1 0 . 8 为变量指定单一用途
关键点
第1 1 章 变量名的力量
1 1 . 1 选择好变量名的注意事项
最重要的命名注意事项
以问题为导向
最适当的名字长度
变量名字的效果范围
变量名字中的计算值限定词
变量名字中的常用反义词
1 1 . 2 为特定类型的数据命名
为循环索引命名
为状态变量命名
为临时变量命名
为布尔变量命名
为枚举类型命名
为常量命名
1 1 . 3 命名规则的力量
为什么要有规则？
何时采用命名规则
正式程度
1 1 . 4 非正式命名规则
语言无关规则的指导原则
语言相关规则的指导原则
混合语言编程的注意事项
命名规则示例
1 1 . 5 标准前缀
用户自定义类型缩写
语义前缀
标准前缀的优点
1 1 . 6 创建具备可读性的短名称
一般的缩写指导原则
语音缩写
有关缩写的评论
1 1 . 7 应该避免的名称
关键点
第1 2 章 基本数据类型
1 2 . 1 使用数的普遍规则
1 2 . 2 整数
1 2 . 3 浮点数
1 2 . 4 字符和字符串
C 中的字符串
1 2 . 5 布尔变量
1 2 . 6 枚举类型
如果你的语言里没有枚举类型
1 2 . 7 命名常量
1 2 . 8 数组
1 2 . 9 创建你自己的类型（类型别名）
为什么创建自己的类型的示例是用P a s c a l 和A d a 写的？
创建自定义数据类型的指导原则
关键点
第1 3 章 不常见的数据类型
1 3 . 1 结构
1 3 . 2 指针
用来理解指针的例子
使用指针的一般技巧
C + + 指针
C 指针
1 3 . 3 全局数据
与全局数据有关的常见问题
使用全局数据的理由
只有万不得已时才使用全局数据
用访问子程序来取代全局数据
如何降低使用全局数据的风险
其他资源
关键点

==第4部分 语句==
第1 4 章 组织直线型代码
1 4 . 1 必须有明确顺序的语句
1 4 . 2 顺序无关的语句
使代码易于自上而下的阅读
把相关的语句组织在一起
关键点
第1 5 章 使用条件语句
1 5 . 1 i f 语句
简单i f - t h e n 语句
i f - t h e n - e l s e 语句串
1 5 . 2 c a s e 语句
为c a s e 选择最有效的排序
使用c a s e 语句的提示
关键点
第1 6 章 控制循环
1 6 . 1 选择循环的种类
什么时候使用w h i l e 循环
什么时候用带退出的循环
何时使用f o r 循环
何时使用f o r e a c h 循环
1 6 . 2 循环控制
进入循环
处理好循环体
退出循环
检查端点
使用循环变量
循环应该有多长
1 6 . 3 轻松创建循环——由内而外
1 6 . 4 循环和数组的关系
关键点
第1 7 章 不常见的控制结构
1 7 . 1 子程序中的多个返回
1 7 . 2 递归
递归的例子
使用递归的技巧
1 7 . 3 g o t o
反对g o t o 的论点
支持g o t o 的观点
关于g o t o 的虚假辩论
错误处理和g o t o
g o t o 和在e l s e 子句中的共享代码
g o t o 使用原则总结
1 7 . 4 对不常见控制结构的看法
其他资源
关键点
第1 8 章 表驱动方法
1 8 . 1 表驱动方法使用总则
使用表驱动方法的两个问题
1 8 . 2 直接访问表
示例：一个月中的天数（D a y s - i n - M o n t h ）
示例：保险费率
例子：灵活的消息格式（F l e x i b l e - M e s s a g e - F o r m a t ）
构造查询键值
1 8 . 3 索引表访问（I n d e x e d
1 8 . 4 阶梯访问表
1 8 . 5 表查询的其他示例
关键点
第1 9 章 一般控制问题
1 9 . 1 布尔表达式
用t r u e 和f a l s e 做布尔判断
简化复杂的表达式
编写肯定形式的布尔表达式
用括号使布尔表达式更清晰
理解布尔表达式是如何求值的
按照数轴的顺序编写数值表达式
与0 比较的指导原则
布尔表达式的常见问题
1 9 . 2 复合语句（块）
1 9 . 3 空语句
1 9 . 4 驯服危险的深层嵌套
对减少嵌套层次的技术的总结
1 9 . 5 编程基础：结构化编程
结构化编程的三个组成部分
1 9 . 6 控制结构与复杂度
复杂度的重要性
降低复杂度的一般原则
其它类型的复杂度
关键点

==第5部分 代码改善==
第2 0 章 软件质量概述
2 0 . 1 软件质量的特性
2 0 . 2 改善软件质量的技术
开发过程
设置目标
2 0 . 3 不同质量保障技术的相对效能
缺陷检测率
找出缺陷的成本
修正缺陷的成本
2 0 . 4 什么时候进行质量保证工作
2 0 . 5 软件质量的普遍原理
推荐读物
相关标准
关键点
第2 1 章 协同构造
2 1 . 1 协同开发实践概要
协同构造是其他质量保证技术的补充
协同构造有利于传授公司文化以及编程专业知识
集体所有权适用于所有形式的协同构造
在构造前后都应保持协作
2 1 . 2 结对编程
成功运用结对编程的关键
结对编程的好处
2 1 . 3 正式检查
你期望检查能够带来什么结果
检查中的人员角色
检查的一般步骤
检查中的自尊心
检查和代码大全
检查总结
2 1 . 4 其他类型的协同开发实践
走查
代码阅读
大型演示
协同构造技术的比较
参考资料
结对编程
检查
相关标准
关键点
第2 2 章 开发者测试
2 2 . 1 开发者测试在软件质量中的角色
构造中测试
2 2 . 2 推荐的开发者测试方法
先测试还是后测试
开发者测试的局限性
2 2 . 3 测试技巧锦囊
不完整的测试
结构化的基础测试
数据流测试
等价类划分
猜测错误
边界值分析
几类坏数据
几类好数据
采用容易手工检查的测试用例
2 2 . 4 典型错误
哪些类包含最多的错误？
错误的分类
不完善的构造过程引发错误所占的比例
你期望能发现多少错误
测试本身的错误
2 2 . 5 测试支持工具
为测试各个类构造脚手架
D i f f 工具
测试数据生成器
覆盖率监视器
数据记录器/ 日志记录器
符号调试工具
系统干扰器
错误数据库
2 2 . 6 改善测试过程
有计划的测试
重新测试（回归测试）
自动化测试
2 2 . 7 保留测试记录
个人测试记录
推荐读物
测试
测试脚手架
测试优先的开发
相关标准
关键点
第2 3 章 调 试
2 3 . 1 调试概述
调试在软件质量中所扮演的角色
调试效率的巨大差异
让你有所收获的缺陷
一种效率低下的调试方法
2 3 . 2 寻找缺陷
科学的调试方法
寻找缺陷的一些小建议
语法错误
2 3 . 3 修正缺陷
2 3 . 4 调试中的心理因素
心理取向如何导致调试时的盲目
“心理距离”在调试中的作用
2 3 . 5 调试工具——明显的和不那么明显的
源代码比较工具
编译器的警告消息
扩展的语法和逻辑检查
执行性能分析器
测试框架
调试器
其它资源
关键点
第2 4 章 重构
2 4 . 1 软件进化的类型
软件进化的哲学
2 4 . 2 重构简介
重构的理由
拒绝重构的理由
2 4 . 3 特定的重构
数据级的重构
语句级的重构
子程序级重构
类实现的重构
类接口的重构
系统级重构
2 4 . 4 安全的重构
不宜重构的情况
2 4 . 5 重构策略
推荐读物
关键点
第2 5 章 代码调整策略
2 5 . 1 性能概述
质量特性和性能
性能和代码调整
2 5 . 2 代码调整简介
P a r e t o 法则
一些无稽之谈
何时调整代码
编译器优化
2 5 . 3 蜜糖和哥斯拉
常见的低效率之源
常见操作的相对效率
2 5 . 4 性能测量
性能测量应当精确
2 5 . 5 反复调整
2 5 . 6 代码调整方法总结
推荐读物
算法和数据类型
关键点
第2 6 章 代码调整方法
2 6 . 1 逻辑
在知道答案后停止判断
按照出现频率来调整判断顺序
相似逻辑结构之间的性能比较
用查找表替代复杂表达式
使用惰性求值
2 6 . 2 循环
将判断外提（U n s w i t c h i n g ）
合并循环
？？？？？展开
尽可能减少再循环内部做的工作
哨兵值
把最忙的循环放在最内层
削减强度
2 6 . 3 数据变换
使用整型数而不是浮点数
数组维度尽可能少
尽可能减少数组引用
使用辅助索引
使用缓存机制
2 6 . 4 表达式
利用代数恒等式
削弱运算强度
编译时初始化
小心系统函数
使用正确的常量类型
预先算出结果
删除公共子表达式
2 6 . 5 子程序
将函数重写为内联
2 6 . 6 用低级语言重写代码
2 6 . 7 变得越多，事情反而更没变
推荐读物
关键点

==第6部分 系统考虑==
第2 7 章 程序规模对“构筑”的影响
2 7 . 1 交流和规模
2 7 . 2 项目规模的范围
2 7 . 3 项目规模对错误的影响
2 7 . 4 项目规模对生产率的影响
2 7 . 5 项目规模对开发活动的影响
活动比例和项目规模
程序、产品、系统和系统产品
方法论和规模
额外资源
关键点
第2 8 章 管理“构筑”
2 8 . 1 鼓励良好的编码实践
设定标准的考虑事项
鼓励良好的编码实践的技术
本书的角色
2 8 . 2 配置管理
什么是配置管理？
需求变更和设计变更
软件代码变更
工具版本
机器配置
备份计划
有关配置管理的额外资源
2 8 . 3 评估“构筑”进度表
评估的方法
评估“构筑”的工作量
对进度的影响
评估与控制
如果你落后了该怎么办
有关软件评估的额外资源
2 8 . 4 度量
有关软件度量的额外资源
2 8 . 5 把程序员当人看
程序员们怎样花费时间？
性能差异与质量差异
信仰问题
物理环境
有关“把程序员当人看”的额外资源
2 8 . 6 管理你的管理者
有关管理构造的额外资源
相关标准
关键点
第2 9 章 集成
2 9 . 1 集成方式的重要性
2 9 . 2 集成频率——阶段式集成还是增量集成
阶段式集成
增量集成
增量集成的益处
2 9 . 3 增量集成的策略
自顶向下集成
自底向上集成
三明治集成
风险导向的集成
功能导向的集成
T - 型集成
集成方法小结
2 9 . 4 D a i l y
哪种项目能用d a i l y
持续集成
额外资源
关键点
第3 0 章 编程工具
3 0 . 1 设计工具
3 0 . 2 源代码工具
编辑
分析代码质量
重构源代码
V e r s i o n
数据词典
3 0 . 3 可执行码工具
产生目标码
除错
测试
代码微调
3 0 . 4 工具导向的环境
3 0 . 5 打造你自己的编程工具
项目特有的工具
脚本
3 0 . 6 工具幻境
额外资源
关键点

==第7部分 软件工艺==
第3 1 章 布局与风格
3 1 . 1 基本原则
布局的极端情况
格式化的基本原理
人和计算机对程序的解读
好布局有什么用？
把布局作为一种信仰
良好布局的目标
3 1 . 2 布局技术
空白区
括号
3 1 . 3 布局风格
纯块结构
模仿纯块结构
使用b e g i n
行尾布局
哪种风格最优？
3 1 . 4 控制结构的布局
格式化控制结构块的要点
其他考虑
3 1 . 5 单条语句的布局
语句长度
用空格使语句显得清楚
格式化后续行
每行仅写一条语句
数据声明的布局
3 1 . 6 注释的布局
3 1 . 7 子程序的布局
3 1 . 8 类的布局
类接口的布局
类实现的布局
文件和程序布局
更多资源
关键点
第3 2 章 自说明代码
3 2 . 1 外部文档
3 2 . 2 编程风格作文档
3 2 . 3 注释或不注释
3 2 . 4 高效注释之关键
注释种类
高效注释
最佳注释量
3 2 . 5 注释技术
注释单行
注释代码段
注释数据声明
注释控制结构
注释子程序
注释类、文件和程序
3 2 . 6 I E E E 标准
软件质量保证标准
更多资源
关键点
第3 3 章 个人性格
3 3 . 1 个人性格是否和本书话题无关
3 3 . 2 聪明和谦虚
3 3 . 3 求知欲
3 3 . 4 诚实
3 3 . 5 交流与合作
3 3 . 6 创造力和纪律
3 3 . 7 偷懒
3 3 . 8 不像你想象中那样起作用的性格
矜持
经验
编程狂人
3 3 . 9 习惯
更多资源
关键点
第3 4 章 软件开发艺术的有关问题
3 4 . 1 克服复杂性
3 4 . 2 精选编程过程
3 4 . 3 为人写程序，其次才是为机器
3 4 . 4 以所用语言编程，但思路不受其约束
3 4 . 5 借助规范集中注意力
3 4 . 6 基于问题域编程
将程序划分为不同层次的抽象
3 4 . 7 “当心落石”
3 4 . 8 反复，再反复
3 4 . 9 不要顽固不化
判断
折中主义
试验
关键点
第3 5 章 何处有更多信息
3 5 . 1 关于软件创建的信息
3 5 . 2 创建之外的话题
综述资料
软件工程综览
其他注释过的参考书目
3 5 . 3 期刊
初级程序员杂志
高级程序员杂志
专题出版物
3 5 . 4 软件开发者的读书计划
入门级
熟练级
精通级
3 5 . 5 参加专业组织

