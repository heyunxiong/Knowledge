# 单例模式

简述：对某个类只能存在一个对象实例，该类只提供一个获取对象实例的方法（静态方法）。如常见的Hibernate框架上的SessionFactory这种用来开启会话的类，一般都会被设计成只需要一个对象即可。

# (1）饿汉式（静态常量）

步骤：

1. 构造器私有化
2. 类内部创建对象
3. 暴露静态共有方法获取对象 getInstance( )



优缺点

优点：写法简单，使用静态方法，在类加载的时候就完成对象的实例化，能避免线程同步问题

缺点：正是因为类加载就创建对象，没有达到lazy loading 的效果，如果自始至终也没有用到这个对象，那么将会造成内存资源浪费



# （2）饿汉式（静态代码块）

步骤：

1. 构造器私有化
2. 类内部创建对象

1. 1. 使用静态代码块创建对象

1. 暴露静态共有方法获取对象 getInstance( )

//code

优缺点：

创建方式其实和上面使用静态变量创建类似，创建对象实例的过程也是在类装载的时候，只是放在了静态代码块而已。



（3）懒汉式（线程不安全）

1. 私有化构造器
2. 静态变量instance
3. 提供一个静态的共有方法，使用到该方法才创建Instance

1. 1. 判断是否存在instance实例

//code

优缺点：

优点：起到了lazy loading 的效果，但是只能在单线程下使用

缺点：对于if（instance == null）判断的时候，可能一个线程刚判断完进去准备创建对象，此时对象还没有创建出来（创建对象也是需要时间的，尽管再短时间），另一个线程也就开始了判断，也能进来创建对象，最后的结果就是可能会有两个或多个对象实例。

实际开发中不建议使用该方式，有潜在风险



（4）懒汉式（线程安全，同步方法）

1. 私有化构造器
2. 静态变量instance
3. 提供一个静态的公有方法，使用到该方法才创建Instance，使用synchronized关键字解决线程安全问题

1. 1. 判断是否存在instance实例

//code

优缺点：

优点：起到了lazy loading 得效果，也解决了线程安全的问题，

缺点：但是效率低了，每个线程获取该实例都需要进行同步，实际上只是想创建的时候同步，获取的时候不需要同步，直接返回就行了

实际开发也不推荐，效率低



（5）懒汉式（线程安全，同步代码块）

1. 私有化构造器
2. 静态变量instance
3. 提供一个静态的公有方法，使用到该方法才创建Instance

1. 1. 判断是否存在instance实例

使用synchronized，划分锁的粒度

//code

优缺点

优点：解决了效率问题，现在创建时同步，获取时候如果已经创建了就直接返回

缺点：其实有存在线程安全的问题，原因也是在判断 if（instance == null） 这里

实际开发中不能用。



（6）双重检查（推荐使用）



1. 私有化构造器
2. 静态变量instance，需要用可见性关键字volatile 修饰
3. 提供一个静态的公有方法，使用到该方法才创建Instance

1. 1. 判断是否存在instance实例

使用synchronized，划分锁的粒度

再判断一次instance是否为null ，这次的判断是为了首次调用getInstance防止有多个线程创建对象，解决创建对象线程安全问题。

//code

优缺点：

优点：有lazy laoding 效果，能解决线程安全问题，也可以解决效率问题，实例化代码只执行一次，后面再次访问直接返回

推荐使用



# （7）静态内部类



1. 私有化构造器
2. 使用内部静态类的静态属性获取Singleton实例
3. 提供获取内部类静态属性的方法

//code

优缺点

优点：静态内部类的加载不会因为外部类的加载而马上实例化，而是需要实例化的时候才进行。也就是调用了getInstance（）时候，触发了获取内部类的静态属性，从而使得静态内部类开始实例化。实现了lazy loaidng 效果

同时，由于静态内部类的加载是线程安全的，jvm内部进行了控制，且只会加载一次。

推荐使用



# （8）枚举

1. 创建枚举类Singleton

//code

优缺点：

优点：能解决线程安全同步的问题，而且还能防止反序列化重新创建新的对象

强烈推荐使用







# 小结

单例模式注意事项和细节说明

单例模式保证了，系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能

2）当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new

3）单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、 session工厂等）